#use <conio>
#use <util>

typedef struct dll_node dll;
struct dll_node {
	dll* prev;
	char data;
	dll* next;
};

// start and end are dummy pointers
// add a cursor which is the position where edits can be made
// edits happen to the left of the cursor
// cursor can be point to same node that end points to
// (edit at the end of the text buffer)

typedef struct tbuf_header tbuf;
struct tbuf_header {
	dll* start;
	dll* cursor;
	dll* end;
};

bool has_cycle(dll* head) {
	dll* slow = head;
	dll* fast = head;

	while (fast != NULL && fast->next != NULL) {
		slow = slow->next;
		fast = fast->next->next;
		if (slow == fast) {
			return true;
		}
	}

	return false;
}

bool cursor_outside(tbuf* B) 
//@requires B != NULL;
//@requires !has_cycle(B->start);
{
	for (dll* i = B->start; i != NULL; i = i->next) {
		if (B->cursor == i) return false;
		if (i == B->end) return true;
	}

	return true;
}

bool reachable(dll* start, dll* end) 
//@requires start != NULL && end != NULL;
//@requires !has_cycle(start);
{
	for (dll* p = start; p != NULL; p = p->next) {
		if (p == end) return true;
	}
	return false;
}

bool is_dll(dll* start, dll* end) 
//@requires start != NULL && end != NULL;
//@requires !has_cycle(start);
//@requires reachable(start, end);
{
	dll* prev = NULL;

	for (dll* p = start; p != NULL; p = p->next) {
		if (prev != NULL && prev != p->prev) {
			return false;
		}
		prev = p;
	}

	return true;
}

bool is_tbuf(tbuf* B) {
	if (B == NULL) return false;
	if (has_cycle(B->start)) return false;
	if (!reachable(B->start, B->end)) return false;
	if (!is_dll(B->start, B->end)) return false;
	if (cursor_outside(B)) return false;
	return true;
}

bool tbuf_at_left(tbuf* B) 
//@requires is_tbuf(B);
{
	return B->cursor == B->start->next;
}

bool tbuf_at_right(tbuf* B)
//@requires is_tbuf(B);
{
	return B->cursor == B->end;
}

tbuf* tbuf_new() 
//@ensures is_tbuf(\result);
//@ensures tbuf_at_right(\result);
{
	dll* head = alloc(dll);
	dll* tail = alloc(dll);
	
	head->next = tail;
	tail->prev = head;

	tbuf* B = alloc(tbuf);
	B->start = head;
	B->cursor = tail;
	B->end = tail;
	return B;
}

void tbuf_forward(tbuf* B)
//@requires is_tbuf(B);
{
	if (tbuf_at_right(B)) {
		return;
	}

	B->cursor = B->cursor->next;
	return;
}

void tbuf_backward(tbuf* B)
//@requires is_tbuf(B);
{
	if (tbuf_at_left(B)) {
		return;
	}
	B->cursor = B->cursor->prev;
	return;
}

char tbuf_delete(tbuf* B)
//@requires is_tbuf(B);
{
	if (tbuf_at_left(B)) {
		return '\0'; 
	}

	dll* target = B->cursor->prev;

	B->cursor->prev = target->prev;
	target->prev->next = B->cursor;
	return target->data;
}

void tbuf_insert(tbuf* B, char c) 
//@requires is_tbuf(B);
{
	dll* new_node = alloc(dll);

	new_node->next = B->cursor;
	new_node->prev = B->cursor->prev;
	new_node->data = c;

	B->cursor->prev->next = new_node;
	B->cursor->prev = new_node;
}
