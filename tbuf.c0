#use <conio>
#use <util>

typedef struct dll_node dll;
struct dll_node {
	dll* prev;
	char data;
	dll* next;
};

// start and end are dummy pointers
// add a cursor which is the position where edits can be made
// edits happen to the left of the cursor
// cursor can be point to same node that end points to
// (edit at the end of the text buffer)

typedef struct tbuf_header tbuf;
struct tbuf_header {
	dll* start;
	dll* cursor;
	dll* end;
};

bool has_cycle(dll* head) {
	dll* slow = head;
	dll* fast = head;

	while (fast != NULL && fast->next != NULL) {
		slow = slow->next;
		fast = fast->next->next;
		if (slow == fast) {
			return true;
		}
	}

	return false;
}

bool cursor_outside(tbuf* B) 
//@requires B != NULL;
//@requires !has_cycle(B->start);
{
	for (dll* i = B->start; i != NULL; i = i->next) {
		if (B->cursor == i) return false;
		if (i == B->end) return true;
	}

	return true;
}

bool reachable(dll* start, dll* end) 
//@requires start != NULL && end != NULL;
//@requires !has_cycle(start);
{
	for (dll* p = start; p != NULL; p = p->next) {
		if (p == end) return true;
	}
	return false;
}

bool is_dll(dll* start, dll* end) 
//@requires start != NULL && end != NULL;
//@requires !has_cycle(start);
//@requires reachable(start, end);
{
	dll* prev = NULL;

	for (dll* p = start; p != NULL; p = p->next) {
		if (prev != NULL && prev != p->prev) {
			return false;
		}
		prev = p;
	}

	return true;
}

bool is_tbuf(tbuf* B) {
	if (B == NULL) return false;
	if (has_cycle(B->start)) return false;
	if (!reachable(B->start, B->end)) return false;
	if (!is_dll(B->start, B->end)) return false;
	if (cursor_outside(B)) return false;
	return true;
}

bool tbuf_at_left(tbuf* B) 
//@requires is_tbuf(B);
{
	return B->cursor == B->start->next;
}

bool tbuf_at_right(tbuf* B)
//@requires is_tbuf(B);
{
	return B->cursor == B->end;
}


